<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>User Intentions Explainer</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "unofficial"
          ,   shortName:    "intentsions-explainer"
          ,   editors:      [{ name: "Ben Peters", 
                               mailto: "BenjamP@microsoft.com",
                               company: "Microsoft", 
                               companyURL: "http://www.microsoft.com" },
                             { name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" }]
          ,   wg:           ""
          ,   wgURI:        ""
          ,   wgPublicList: "public-webapps"
          ,   wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/40318/status"
          ,   edDraftURI:   ""
          ,   license:      "cc-by"
        };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document is a non-normative reference, which provides an overview of the various ways to understand and respond to User Intentions on a site or app. 
        It summarizes the normative information in the each respective specification in easy-to-digest prose with illustrations.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This specification is an 
        <a href='http://dev.w3.org/html5/decision-policy/html5-2014-plan.html#extension-specs'>extension
        specification</a> to HTML.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        Today, sites mostly respond to user Actions directly, causing several issues including difficultly understanding what a user intends, complexity in building Accessible sites, and complex localization.
        In addition, while some areas like Clipboard already support User Intensions, it is important that all such areas share a common API shape.
        This document is meant to describe the path forward for User Intentions across multiple areas so that sites can be written more simply and Intentions APIs can have a unified shape.
      </p>
    </section>
    <section>
      <h2>Framing the Problem</h2>
        <ul><li>There are <b>many ways to indicate user Intentions</b> and no clean way to understand them all
        </li><li>Accessibility tools have <b>difficulty understanding available actions</b>
        </li><li>Frameworks and sites may have <b>difficulty understanding what is implemented</b>, what should show up on toolbars and menus, and what needs to be polyfilled in editing scenarios
        </li><li>There is no uniform way for a component or a script to issue an application-independent request to provoke some change on the UI (e.g. scroll or zoom)</li>
        </ul>        
    </section>
    <!--
    <section>
        <h2>Use Cases</h2>
    </section>
    -->
    <section>
        <h2>Definitions and Goals</h2>
        <p>Definitions:</p>
        <b>Action:</b> any way a user interacts with a webpage, including click, type, touch, and gesture<br>
        <b>Action Event:</b> a script event that is fired before a user Action takes effect
        <b>Intention:</b> what a user/component is trying to do by performing an action, including select, undo, insert text, and delete<br>
        <b>Intention Event:</b> a script event that is fired before a user Intention takes effect
        <b>Behavior:</b> the result of an Intention in a browser, framework, or site
        <p>Goals:</p>
        <ul><li>Make it easy to implement custom Behavior for a given Intention with appropriate APIs
        </li><li>Allow overwrite of Behavior for a user Intention from all actions that indicate that Intention
        </li><li>Enumerate the possible Behaviors in a given context such that toolbars and Accessiblity tools can inform users what's available and what has occurred
        </li><li>Empower complex sites to be accessible by enabling users to understand available Behaviors with little accessibility-specific work from the framework or site
        </li><li>Enable components and scripts to interact with the UI on an abstract level, thus imporving reuse
        </li>
        </ul>
    </section>
    <section>
        <h2>Visualizing User Intentions</h2>
        Today, user Intentions can only be inferred from user Actions and the resulting Action Events in most cases.
        Frameworks and sites have trouble changing browser Behaviors and implementing custom Behaviors because of this inference-based sysmtem.
        Accessibility tools and toolbars also have trouble understanding what is site is doing because the inference-based system does not clearly 
        articulate what type of Behavior has occurred. The following diagram shows how sites try to determine what a user wants to do:</br>
        <img alt="Image depicting current state described above." src="images/Intensions_Present.png"><br>
        Ideally, sites should have a more direct way of understanding what a user is trying to do. 
        Additionally, Accessibility Tools and other input modalities should be able to list available Intentions
        and understand what has occurred in order to provide feedback to users.
        The following diagram shows how this could work better:<br>
        <img alt="Image depicting ideal state described above." src="images/Intentions_Goal.png"><br>
    </section>
	<section>
      <h2>Roadmap</h2>
      <p>The following roadmap explains what we believe is necessary to accomplish our goals.</p>
      <ol>
      <li>Gain Support<p>This is under way. We are gathering support from browsers, sites, and frameworks.</p></li>
      <li>Frame the problem<p>We have a draft of this above, including use cases.</p></li>
      <li>Determine a possible solution<p>Our current thoughts on this are around an eventing system, as described below. It will need to be refined with more detailed shape, more thorough API, and further developer input.</p></li>
      <li>Create a prototype of the solution<p>A first-draft prototype is linked below. It needs a lot more before it can be adequately tested.</p></li>
      <li>Try to solve the initial problems using the prototype<p>This is the next big step.</p></li>
      <li>Refine our solution based on this testing<p>Coming soon.</p></li>
      <li>Work with other specs like Clipboard, Selection, DOM Events, and IndieUI<p>This is an ongoing process, but the final goal is to ensure that all (or most) Intention-style events share a common shape.</p></li>      
      </ol>
	</section>
    <section>
      <h2>Intention Events</h2>
        <section>
        <h3>Overview</h3>
        <p>In order to solve this problem, JavaScript needs a new level of abstraction for user Intentions. 
        Intention Events are one option for that abstraction. 
        There are several types of Intention Events, including text input (beforeInput events), Clipboard, and Selection (beforeSelectionChange events). 
        Building on the concepts that already exist in Clipboard events and those that are being specified by <a href="http://www.w3.org/TR/selection-api/">Selection API</a>,
        we unify the story across other Intentions types such as the beforeInput event.
        The picture would look like this, where Actions cause Action Events, which may result in Intention Events from browsers or sites, which may result in implemented Behaviors from browsers or sites:
        </p><p>
            <img alt="Image depicting range of Actions, Action Events, Intention Events, and default handling of those events, as described above." src="images/intention_events_concept.png">
        </p>
		</section><section>
        <h3>Clipboard Events</h3>
        In order to assist in determining what a user intends, browsers already fire some events for user intentions, like Clipboard Events. 
        The <code>type</code> of a <code>ClipboardEvent</code> indicates the user's Intention.
        </section><section>
        <h3>Selection Events</h3>
        <code>BeforeSelectionChange</code> events will also help determine a user's Intention. They are being considered for the Selection API spec.
        A <code>commandType</code> property of a Selection event can indicate the user's Intention, such as extendSelection.
        <p class="issue">This doesn't exist yet. Need to work with Ryosuke Niwa and Selection API on this</p>
        </section><section>
        <h3>BeforeInput Events</h3>
        Just like for Clipboard and Selection, a user's Intention to do various input (like typing or formatting text) should be easily understandable by script.
        This allows sites to override Behaviors as they see fit.
        For instance, if a site wants to manage the way bolding text works, they can list for a <code>BeforeInput</code> with commandType="bold",
        execute their own custom bold Behavior, and <code>preventDefault()</code>.
        They no longer need to listen for control+b on English keyboards or something else in other locales.
        Any platform-specific bold toolbars or gestures just work with their <code>BeforeInput</code> implementation as well.
        <p class=issue>How do IMEs (Input Method Editors) fit in here? Are CompositionEvents a type of Intention?</p>
        </section><section>
        <h3>Ways to Fire Intention Events</h3>
        <section>
        <h3>Well-known Sources</h3>
        Intention Events may be fired by browsers for all well-known ways a user would indicate their Intention. 
        For instance, control+c should fire the required <code>KeyboardEvent</code>s, and if preventDefault() is not called on them,
        it would then fire a <code>ClipboardEvent</code> of type "copy". 
        Similarly, the "shake" gesture on iOS would fire a <code>BeforeInput</code> with <code>commandType="undo"</code>.
        </section><section>
        <h3>Custom Sources</h3>
        <p>
        Different sites and apps have different ways that users indicate their Intentions.
        For instance, a toolbar on an email site might have formatting buttons,
        or a code editor app might have different keyboard shortcuts.
        In order to enable web developers to fire their own Intention Events when their users are indicating an Intention,
        a new function (as yet unnamed, but here referred to as declareIntention()) will cause Intention Events to be fired. 
        </p><p>
        For example, clicking the following button would fire a <code>beforeInput</code> event with commandType "bold". 
        If preventDefault is not called on that event,
        then the browser would perform its default action for bold.
        <code class="highlight"><pre class="example">&lt;input type="button" onclick="declareIntention('bold')" value="b"&gt;</pre></code>

        </p><p>
        Further, if a keyboard shortcut indicates a different Intention for a given site or app,
        it can be overwritten like this:<br>
        <code class="highlight"><pre class="example">function handleKeydown(evt) {
    if (evt.ctrlKey && evt.key === "s") {
        document.declareIntention('strikeThrough');
        evt.preventDefault();
    }
}</pre></code> 
        Now control+s is bound to strikeThrough instead of its default.        
        </p>
        </section><section>
        <h3>The <code>CommandData</code> Object</h3>
        <p>
        Some Intention Events will have more information than just a <code>commandType</code>. 
        In order to encapsulate this data, a new object called <code>CommandData</code> will be used, 
        which has a <code>value</code> attribute.
        It can be extended for a given Intention that needs more data than just a <code>value</code>.
        </p><p>
        A possible signature for declareIntention might be the following:
        <code class="highlight"><pre>declareIntention (DOMString commandId, optional CommandData commandData)</pre></code>
        </p><p>
        Each Intention Event type (Clipboard, Selection, and BeforeInput) will have a new property for getting this object, <code>commandData</code>.
        </p><p>
        For example, a bold Intention that specifies the target value of bold can be initiated like this:
        <code><pre>document.declareIntention('bold', {"value":"true"});</pre></code>
        When the associated BeforeInput event is fired, its <code>commandData</code> attribute will have <code>value="true"</code>.
        </p>
        </section>
        </section><section>
        <h3>Custom Intention Events</h3>
        This functionality is fully extensible. If a site wishes to fire a custom command, it can do so by using any DOMString for the commandType of declareIntention.
        This will generate a CommandEvent with the same commandType, which will have no default action by definition.
        But listening to for the CommandEvent will allow the site to handle this custom Intention in the same way it handles well-known Intentions. 
        See <a href='#use-cases-and-samples'>the example</a> at the bottom for more details.
        <p class="issue">Need to figure out if we can do custom when using beforeInput instead of Command. Seems odd. Maybe we need Command for non-text things? 
        Also, how can a custom Intention know if it is text input or seletion or something else?</p>
        </section>
    </section>
    <section>
    <h2>Prototype</h2>
    <p>A prototype is available <a href="http://w3c.github.io/editing-explainer/demos/intentions-demo.html">here</a>.</p>
    </section>
    <section>
    <h2>Samples</h2>
    <section>
    <h3>Override Basic Functionality</h3>
    <p>
    With the following code, a site can handle several different custom commanding scenarios in a consistent way. 
    First, it is able to perform a custom bold command that will work with any method of invoking bold, 
    including different keyboard shortcuts in different localizations, and different input modalities on different devices. 
    Second, it can perform some new functionalities- "grammarCheck" and "markCode"- using the same code path as its custom bold. 
    The definition of the custom functions is omitted because the goal here is to show how simple it is to do command routing.
    </p><p>
    <code class="highlight"><pre class="example">var editRegion = document.getElementById("editRegion");
editRegion.addEventListener("keydown", handleKeyDown);
editRegion.addEventListener("beforeInput", handleBeforeInput);

function handleKeyDown(evt){
    switch (evt.key){
    case "g":
        if (evt.ctrlKey){
            document.declareIntention("grammarCheck");
            evt.preventDefault();
        }
        break;
    }
    case "c":
        if (evt.ctrlKey && evt.shiftKey){
            document.declareIntention("markCode");
            evt.preventDefault();
        }
        break;
    }
}

function handleBeforeInput(evt){
    switch (evt.commandType){
    case "bold":
        customBold();
        break;
    case "grammarCheck":
        customGrammerCheck();
        break;
    case "markCode":
        customMarkAsCode();
        break;
    }
}</pre></code>
    </p>
    </section><section>
    <h3>Example Intention Events</h3>
    
        Here a list of some sample Intention Events:<br>
        <code>BeforeInput</code>; <code>commandType="insertText"</code>; used for typing text<br>
        <code>BeforeInput</code>; <code>commandType="insertNewline"</code> <br>
        <code>Beforeinput</code>; <code>commandType="italic"</code><br>
        <code>ClipboardEvent</code>; <code>type="copy"</code><br>
        <code>BeforeSelectionChangeEvent</code>; <code>commandType="extendSelection"</code>; similar to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection.extend"><code>Selection.extend()</code></a>, works with keyboard/pointer input<br>        
    </section></section><section>
	<h2>Relationship to IndieUI</h2>
		<p><a href="http://www.w3.org/TR/indie-ui-events/">IndieUI: Events 1.0</a> is solving a similar problem. 
		The abstract of that spec says "This provides an intermediate layer between device- and modality-specific user interaction events, 
		and the basic user interface functionality used by web applications."
		The list of Intentions it handles is given in the <a href="http://www.w3.org/TR/indie-ui-events/#eventslist">Event List</a> of that document.
		A great deal of effort and work has gone into that document, and it has many valuable insights.
		</p><p>
		This Intentions Explainer is solving this problem by starting with concepts that the Editor uses today, such as Input, Selection, and contentEditable. 
		IndieUI appears to be starting with concepts from Accessibility. 
		It is important for these two efforts to come together and solve these problems for both of these scenarios. 
		Understanding a user's Intentions is crucial when there are so many ways that a user can declare them.
		</p>
	</section>
  </body>
</html>
